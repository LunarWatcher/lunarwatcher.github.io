---
title: "Devlog 7: planning"
date: 2022-10-03T22:53:41+02:00
series: ["devlogs"]
slug: devlog-7
---

## Delays

Around a week after the previous devlog, I got hit with a pretty hard cold. To add insult to injury, this was the first time in around 4 years (!), which is a solid personal record, and way down from the four mild colds per year on average. Not stonks for my immune system, but whatever.

Long story short, this pushed work that I'm trying to catch up with, and I've more or less done that. However, the cold did last long enough to tank my spare time for a couple weeks, so my previous devlog isn't on schedule. Uni takes priority over the projects I do for fun, for reasons that should be obvious.

dnf2b isn't up and running. An OS update to 64 bit raspbian (and a considered NUC-style server to assist with more computationally heavy or storage-heavy computing, as my Pi is at its capacity) has also distracted me. The OS update also naturally removed all defenses my Pi had, so I've taken the Pi completely off the public internet in the meanwhile. This is something I'll have to revisit before christmas, when it has to go live again, but for a month or two, future me problem. 

## Yet another format update

Relatively regular devlogs as a format, while good, doesn't work.

Uni has once again started, which means I'm back to a very varied schedule for free time, and as mentioned, the cold screwed over a whole bunch of my plans. I also realised that sinking this much time into a high-resolution public devlog is not worth it. I do still keep internal notes, but that's for my own continued progress and tracking. I may make a post about my system at some point alongside a reformatted version of an article I had planned on my use of bullet journals, but that article is now dead because I don't think anyone really cares. More importantly, though, _I_ don't care about it, so it's axed. 

Speaking of notes...

## Genesis: a new direction

I haven't done gamedev in years. Even back when I did do it, it was mostly on some Canvas class (pixel-based coloring with lots of pre-defined render methods), that also scaled awfully, may I add.

At the time, it was fine, and I had a lot of fun making some of those games, and it did come with the added benefit of keeping me interested in code.

However, I've gotten substantially better at programming since then, and my ideas and tech overall have gotten better and/or bigger. This and me having an unhealthy obsession with OpenGL shaders has resulted in a lot of side-tracking.

I mean, the game engine is fairly solid for being the first game engine I've made in years (even though it's due a refactor), but there's a lot of questions I simply don't have the answers to.

I _could_ have made my life easier by using a pre-built game engine (such as Unity or Unreal), but only Unreal uses the language I want to use, and both of these systems come with a lot of overhead for stuff I can and want to figure out on my own. Being the easily [nerd snipable](https://xkcd.com/356/) girl I am, this has led to several of these issues becoming things I want to solve now, even though I have nothing that uses it. UI and particularly text is one of the things that haunt me, and I could probably spend many more hours on these problems.

This in turn has taken me away from the iterative model I manage to maintain with most of my other projects; build a thing, find a feature, add feature to thing along with the required framework, rinse and repeat until bored or everything worth implementing has been implemented.

I've therefore had to establish a roadmap that I'm going to follow to the letter to keep me on-track, because observed progression is important as well.

The current roadmap, without any details because they're mostly irrelevant, is:

1. Player control
2. Basic world development
3. Construction
4. Expansion
5. Bigger world
6. Mass-feature additions (the idea is that the core game should be stable enough for all base features to be in place to churn out features)
7. Beyond - super generic and just means the "completion" phase of the primary development, and the release of 1.0.0

My own notes also include stuff to do later, and trade-offs that are fine for the sake of progression.

For instance, stage 1 is all about a static, flat world. Stage 2 does a linear rimworld-style world for the sake of allowing base features to function properly. Then it isn't until stage 6 that the dwarf fortress-style world generation is put into place, because I'm currently not capable of doing so.

I'm sure there are a few people who read this who just go "isn't that common sense?", and well, yes. But it took me embarrassingly long to realise I had gone into that trap, even though I know I'm prone to it in projects I get _really_ excited about.

Honestly, roadmaps are a thing I'm going to continue doing in bigger projects to help keep myself on-track. Won't help the fact that I really do have more projects that are a work in progress than I really should have, but the heart wants what the heart wants.

## Auto-pairs

A different plugin had an incompatibility with auto-pairs that has since been fixed. This primarily marks the move to refusing initialisation in blacklisted filetypes.

To maintain compatibility, the filetype is also blacklisted by default as of 3.0.4 (and, of course, merged into the 4.0.0 branch).

4.0.0 also supports automatic returns both before and after the pair open bracket now.

Hacktoberfest is also upon us now, and based on last year, I still assume that means nothing in practice. Auto-pairs is still opted in, and currently has a good first issue in case someone wants to give vim plugin programming (or low-code; there's a lot of documentation, and a lot more that could be useful) a go.

Still got some refactoring to do on the pair objects, but I'm still not looking forward to that, so I'm continuing to procrastinate it for now. That update represents a substantial shift in the inner logic of auto-pairs, and will enable a whole lot that currently isn't possible, or that's annoying to do.

It's still an important update, but my motivation for it is low, and I have other projects that need more attention.

## upm

Upm has been somewhat neglected as of late, largely because of a shortage of time.

However, it can now compile Vim entirely from Lua. The Lua API still has a lot of work to go, particularly with establishing an event flow to separate certain events.

I did minimal work to get it working at least, but more challenges have appeared before the Lua API is viable. However, just being able to compile and install a fully functional Vim instance is a HUGE step in the right direction for making upm viable.

I still need to define some more APIs for standard compiling tasks (such as CMake), but I'll cross that bridge when I have packages that use it. This may also be the piece I need to get upm working, but I haven't quite decided if I want upm to manage itself like it manages other packages, or if it treats itself as a system package.

Treating it like it's another package does have some major advantages, however; notably, it makes it easier to create a command for testing PRs (because I'm so incredibly jealous of ohmyzsh's `omz pr test 1234`, and it's something I'd like to try to make).

Design is hard, okay?
