---
title: "Devlogs: 2022, week 52-3"
date: 2022-01-02T23:26:20+01:00
series: ["devlogs"]
---

## 02.01.2022

### Genesis

Spent time trying to figure out how I can make the texture atlas expandable. This has to be done in a way that lets me expand past whatever limits I currently have, based on some guesswork surrounding future sizes.

Aside expanding the base game if necessary, I'd also like to open for modding. Based on some light tinkering and general research, I belive a minecraft-like system is optimal.

But on the other hand, [Factorio](https://forums.factorio.com/viewtopic.php?t=20150) flat out passes the raw textures, but this presents a few more challenges, particularly related to how my textures are currently pre-stitched. Manual stitching is done for the fonts, but with the fonts, I'm suspecting an on-demand system is better.

The texture management in general leaves a lot of problems here, but string identifiers lets us disregard paths; effectively, `base:textureType` refers to a base-game texture with the name `textureType`.

This is particularly important because it avoids problems if mod A and B both have a tile called `coal`, because one is `a:coal`, and the other is `b:coal`. Still doesn't avoid conflicting names, but this is currently an insigificant problem.

Unlike hard-coding these, though, it does present a bit of extra overhead. Lookup in `std::unordered_map`s appears to be slower for small maps, and faster for bigger ones, where as `std::map` is constantly `log(n)` or whatever. We'll see what happens here when I get more textures in place.

Annoyingly, this blocks continued work on chunks, because I need to be able to reference textures before I can do anything. I'm also starting to feel like an entity factory might be a good idea.

This is definitely a refactorable area though; for now, I'll roll with string identifiers. They're not used much anyway, so it should be fine for the near foreseeable future, and works a lot better, in my semi-biased opinion.

## 20.01.22

### lunarwatcher.github.io

Decided to set up the GitHub Action to automatically wipe the previous deployment history to reduce repo size. All the history is already contained in the source repo, but with infinitely less noise from when I inevitably make a _tiny_ change to a core template, and a number of files need massive changes in the diff of the produced output.

Nothing is lost, there's less redundant (and honestly useless in this case) data stored, everyone wins.

## 25.01.22

### Genesis

Finished refactoring the texture atlas to make it run on a string-based system. Should be possible to deal with metadata integration from here, as well as potential atlas merger, but this isn't a problem for the near foreseeable future, so deferring to future me.

## 20.02.22-21.02.22

Vim recently made changes to Vim9, and broke the previous autoload syntax. Patched two broken plugins (Pandora and Amber), and caught a bug in Pandora where `[text](//example.com)`-links weren't followed.

## 01.04.22-04.04.22

Started getting back into Acacia, after an embarassingly long round of procrastination. Grammar compiling is now up and running, but it's not particularly solid.

It's incompatible with Windows because Windows is trash. The implementation is also essentially hacking in a form of makefile, because apparently, none of the grammars ship with any form of build system. I'm strongly considering hacking together a CMake script, possibly as a template, and just drop it into whatever directory is being installed. Doing that would make compatibility a lot easier to work with.

On the bright side, it seems that tree-sitter-cli isn't necessary. I have no clue why nvim invokes `tree-sitter generate`, and I honestly don't care for now. It's not required for compiling, so I assume it's version compat? Definitely kicking that can down the road.

I'm also not sure how I want to keep track of parsers. Explicitly requiring matches feels like a hack, and even the current system is only compatible with official grammars. Not really sure how I want to deal with the balance of static and dynamic content. Or rather, I'm not sure how I plan to deal with dynamic parser installation on top of static installation. For instance, assuming some custom function that doesn't currently exist:

```vimscript
import autoload 'acacia'

acacia.Install([
    "cpp",
    "vim",
    ...
])
```

The above shouldn't prevent `:TSInstall some-nth-language`, but it also shouldn't require it to be installed.

Admittedly, this style also requires update caching beyond what currently exists, and that's _definitely_ a can to kick down the road.

Also read a comment by Bram on a GitHub issue saying he was going to look into tree-sitter after Vim9 is done. Not sure what happens to this project when that happens, but my plan is to maintain compatibility with whatever tree-sitter API Vim adds. If I go about this right, I should be able to set it up in a way where I can maintain the server as a polyfill for earlier versions of Vim. Admittedly, the extent of the backwards compat is going to be limited, because the entire thing is built on Vim 9. It's not like Vim 8.1 or certain early patches of Vim 8.2 is going to be able to run it anyway. But that's fine; no matter what happens, tree-sitter is _many_ patches, and possibly a year or two away, and that assumes Bram decides in favor of tree-sitter. If he doesn't, I guess I'll have the only fully functional tree-sitter implementation :p

---

Also got side-tracked into a different form of journaling, which is largely just more extensive notekeeping. https://jrnl.sh seems like a potential candidate, but I'm not sure. Feels far too general, to the extent where it more or less conflicts with my bullet journal. Vimwiki is fairly relevant for it, but it's not a great format. [The curiosity journal](https://shop.answerinprogress.com/collections/version-zero/products/copy-of-curiosity_journal_v1) does get close, but it's far too pure research-oriented. I feel like [Obsidian](https://obsidian.md/) is roughly what I want, but /shrug. It strikes the balance between visuals and functionality, but I have no idea if it'll work out in practice. A combination of a date-based and a data-based system is really what I'm looking for, so paper isn't viable here.

We'll see what I figure out there. Optimally, I'd have a Vim-based solution, but I'm not sure if I'm ready to open pandora's box on that ([Pun not intended](//github.com/lunarwatcher/pandora)), particularly while I'm in the middle of acacia. The benefit with obsidian in that regard, is that it's fully markdown. I can replicate some core features in Vim, either as a part of Pandora, or as a separate plugin, and just have it work. 

What I do know is this; there's far too many options and missing variables for me to figure this out any time soon.
